---
title: Data Warehouse
date: 2019-10-06 19:29:07
tags:
---

数据仓库是面向主题的，集成的，相对稳定的，反映历史变化的数据集合，目的在于支持决策
## 数据建模

### 业务建模：业务建模是针对公司或者部门级的业务进行全方面的梳理和分解
通过与业务部门的充分交流，了解建立数据仓库所要解决的问题的真正含义，确定各个主题下的查询分析要求。业务建模就是一种理解公司业务的很好的方式。通过业务建模可以深入了解各个业务部分的具体业务流程，界定数据仓库建模的范围。
- 顶层模型：从公司整体业务的角度，划分业务模块，以及各个业务模块之间的交互关系。比如公司有交易、财务、营销模块，营销活动发起之前需要申请财务预算。
- 业务域：讲划分的模块逐一进行分解到业务用例。营销活动可分解为，运营人员配置活动信息，用户使用优惠券购买产品。
- 业务流程：讲业务用例做具体的流程分解，具体每一步操作是怎么样的，以及操作之间的次序和依赖关系。
- 业务环节：把一个环节的作业内容标准化，主要涉及流程中每一步的正常情况，异常情况的结果是怎样的等等。

### 概念模型建模：对业务模型进行抽象出来实体以及实体与实体之间的关系
把业务建模的各个业务流程抽象出实体和关系，概念模型关注的是实体和实体之间的关系，对实体的属性没有做过多的考虑，概念建模主要包含一下几个方面：
- 针对关键业务环节部分，抽象出实体
- 确定实体之间的关系，1对1，1对多，还是多对多
- 不断的迭代所有的业务环节
- 将所有抽象出来的实体和关系进行总结，统一的实体汇集在一起，将所有相关的实体关联起来

### 逻辑模型设计(Logical Data Model)：对概念模型进行具体的设计，实体的属性，主键，外键等
也称维度建模，维度建模的三个核心是：总线架构，一致性维度，一致性事实。逻辑建模涉及到整个数据仓库所有层次的模型设计，从DW到DM甚至到了OLAP。逻辑建包含以下几部分：
- 分析主题域：确定要装载到铸具仓库的主题名称，以及各自主题的码键和属性组；主体内的实体，及其容量和更新频率；实体的列的属性
- 粒度模型的设计：通过粗略估算数据量来确定粒度层次的划分，是单一粒度还是多重粒度，比如是天粒度的还是月粒度的
- 数据分割设计：针对某一实体的数据应该是按怎样的方式来分割，一般是按时间来分割，比如把每天的数据放在一个分区里面
- 元数据模型的建立：在各种转换和汇总的过程中建立好元数据模型能，更好的维护和理解数据

逻辑建模是有原则的，满足了这些原则，才能保证数据仓库的稳定性，同时让数据需求方使用起来很容易理解数据，处理数据的效率也很高。
- 粒度性：数据仓库不同层次具有的粒度是不同的，DW层数据是原子粒度的数据，比如交易数据原子粒度是订单，记录也包括购买的用户以及商家，DM层的数据是面向主题安一定的维度进行汇总的数据，比如商户集市计算当天出售的订单量
- 共享性：数据仓库中，通过抽象和集成，把一些维度信息汇总起来，做全局的一致化，使其在整个数据仓库中处于共享转态，任何用户都可以来使用。
- 历史性：针对业务分析的需求，需要从历史信息中获取有用的信息，比如评估客户生命周期价值
- 一致性：逻辑数据模型必须在设计过程中保持一个统一的业务定义。比如，渠道的定义、团体的分类等，应该在整个企业内部保持一致。将来各种分析应用都使用同样的数据，这些数据应按照预先约定的规则进行刷新，保证同步和一致性
- 拓展性：当有新的需要和改变的时候，逻辑数据模型结构要能够做到可拓展，并能使得对用户透明。

#### 范式建模
范式建模不仅在线上业务数据库中展现了强劲的风采，也在数据仓库侧发挥着重要的作用，范式建模的难度在于如何抽闲业务，来进行DW建设前夕的准备工作
建模的经典方法有：Inmmon以范式建模为理论基础的集线器式建模，Kimball以维度建模为理论的总线式建模。
Inmon最初的建模理论是通过构建一个符合三范式的集中式的数据中心DW层，此层次的表一般不对BI和应用开放，而是基于DW的数据构建数据集市DM层来对外服务。DM层的数据一般也采用范式建模，不过随后融入了维度建模的思想，把DM层建设成星型模型。但是并未提出使用一致性维度。
范式建模有维护数据的一致性，稳定性，可拓展性，减少冗余，同时也有着规范化但是不利于分析理解数据等特点；所以可以把范式建模利用在ODS和DW层之间的中间明细层数据模型，因为这一层数据承载着DW层的数据，但不会对用户开放。
范式建模采用的是3范式，大多数线上业务数据库也是遵循着3范式的规范，所以简单的业务情况下不需要中间层，直接使用ODS层即可。一下情况，我们还是建议通过范式建模来重新组织数据
- 业务数据库的表没有遵循3范式
- 有复杂的字段需要解析，比如json
- 业务维度比价复杂，很难直接关联去除所需的数据
通过范式建模，可以达到
- 保证数据的一致性，因为避免了数据冗余，即避免了数据的不一致
- 解耦方便维护，也提高了运行效率
- 针对复杂字段的解析和复杂业务的分解，有利于DW层的直接使用

#### 维度建模
维度建模是Kimball提出来的经典的数据仓库建模思想，维度建模提倡针对某一主题，通过建设维度和事实来快速建设数据仓库。
维度建模适合于DW/DM层，通过使用维度建模，用户可以得到很好的效果，只有用户满意了，数据仓库才能实现更大的价值。维度建模也有着一些缺点，比如数据的一致性很难保证，数据的冗余，大量的维度信息处理等。
以维表为总线，事实表以维表为基础的总线矩阵，意味着建设出来的架构就是总线式架构。
维度建模被选择在DW/DM层上实现，是因为维度建模有如下特点：
- 易用性：数据仓库目的是DSS，即决策支持系统(Decision Support System)，既然面向的事分析用户，那么数据越容易理解，越能受用户欢迎，而维度建模包含具有描述特性的维度表可以让用户很容易理解数据，而不像范式建模，由于太过规范化而导致用户对数据理由有一定程度的难度，需要对业务有很深很细的了解。
- 性能高：通过数据处理，排序和整合，构建出来的维度表，不仅能够让用户很方便的理解数据，使用数据，而且在计算所需要的数据的时候，不需要关联太多的表，从而使得计算的性能很高。
- 拓展性：具有非常好的拓展性，以便容纳不可预知的新数据源和新的设计决策。可以很方便在不改变模型粒度情况下，增加新的分析维度和事实，不需要重载数据，也不需要为了适应新的改变而重新编码
在Kimball的理论中，星醒模型在维度建模的时候备受推崇
- 星型模型更具有理解性，毕竟维度模型都是直接挂在事实表，没有额外的关联，所有的维度信息都汇集在维度表中
- 星型模型性能更高。只需要一次的关联就能获取这一维度的所有描述信息
- 冗余程度要更高，所有层次关系的维度，都被设计成扁平化，有一定的冗余。都是维度表的冗余相比事实表毕竟不是一个数量级的。
鉴于以上特点，在维度建模的时候偏向于星型模型。星型模型针对的是单一事实表的情景，当有多个事实表通过维度关联在一起就形成了星座模型，星座模型可以是同一主题不同粒度的事实表之间的关联，也可以是不同主题的事实表共用同一维表。毕竟有全局的一致性维度。

#### 一致性维度
维度建模的核心是一致性维度。
什么事一致性维度：数据仓库的星型模型会使得维度表有一定的冗余，一致性维度主要体现在维度共享性。共享性体现在整个平台或者整个部门共用维度，而不仅仅只是单纯某个业务单独使用。一般的维度并没有把共享性作为一个共性的标准，然而在维度建模中，一致性维度讲作为重心来做。数据仓库70%的工作量和复杂度是用在构建一致性维度。一致性维度讲作用于数据仓库和数据集市甚至OLAP。

什么时候保证一直性维度：一致性维度的构建是先于事实表的构建的，但又不是咋构建完成一致性维度之后才开始构建事实表，在构建的过程中肯定有一定的调整。当在构建事实表的时候如果遇到了比较复杂和困难问题的时候，也要考虑一致性维度构建的是不是合理。

在哪些地方保证一致性维度：90%+的维度表是直接从ODS层进行RTL建设成的，一边都是业务的基本描述信息，这一过程在数据缓冲区来做，输出在数据仓库DW层的最底部。还有一些维度的信息或者属性需要建立在数据集市的基础上，一般是用来做分析的指标或者标签，这个时候需要用集市层的汇总数据来打维度的标签，比如商户的标签，这样的维度信息需要回传到原有的维度表。

如何保证一致性维度：
- 先对业务过程进行梳理，讲业务过程所携带的维度信息整体出来生成总线矩阵。一般情况同属一个价值链的业务过程的维度信息大致相同。
- 然后是针对每个维度逐一审核相关的业务过程，对各个业务过程的维度值进行标准化。
- 对不同的业务的维度信息进行汇总，选择或者生成主键
- 生成维度表，并进行适当的迭代更新

为什么要保证一致性维度：保证一致性维度有利于管理，一致性维度不仅规范化，而且大大减少维度表的数据。其次容易使用，同一主题或者实体的维度表单一，容易获取和使用。所有的事实共享同样的维度，容易进行交叉计算。一致性维度的建设不仅仅能规范化维度模型，大大减少凌乱的维表，而且一旦建设好了一致性维度，那么后面的DW和DM层建设将游刃有余。

#### 如何建设一致性维表
维度表的类型总体上来讲，一般分为两类TYPEI(不变)和TYPEII(变化)
- TYPEI
    - 维度属性值持久不变，只有新增和删除
    - 属性能够在一定周期内不会变化
- TYPEII
    - 缓慢变化维。部分维度属性可变化，但是变化的频率很低
    - 快速变化维。部分维度属性可变化，但是变化的频率很高
- 杂项维度
    - 大量不同的零散的维度整合到一起
TYPEI维表适合于大多数这种维度属性经久不变的信息描述，比如日期维度的大多数属性，门店的地址和名称等。一般来安静业务上的维度信息都是当天不变的，而且DW用户做数据统计分析师按照一定周期来的，一般情况按天为周期。对于生命周期完全不变化的可以构建全量表，其它的建成快照表。在不明确的情况下优先选择快照表，快照不会占用太多的空间
YTPEII：针对缓慢变化维，有些情况下，业务统计周期相对比较短。如果维度变化频次没有那么快的话，可以建成缓慢变化维。比较常见的就是采用effect_from_dt,effect_to_date,current_flag等字段的组合。比如营销过程中，一家门店在几个小时采用的营销手段不同，在统计当天所有交易的成本，如果没有现成的营销数据的话，可以按照交易的时间来匹配当时的营销活动。针对快速变化维，情景和缓慢变化维差不多，如果采用缓慢变化维的构建方式，维表的数据量暴增的很厉害，然而大多数维度属性没有变化，只有个别的属性变化的厉害。这种情况下，可以针对绝大多数不变或者变化频次很低的数据集合建成YTPEI，针对变化频次超快的属性单独建立成微型维度表，这两张表没有依赖关系，都是各自挂载在事实表上的。

维表的主键有两种：自然键，代理键。自然键是有业务含义的ID，比如身份证。代理键是自动生成的唯一键。如果业务ID比较有该业务的独特性(不需要和其它业务集成)，或者共享性(比如公司级别的，门店ID等等)，可以考虑使用自然键，特别是日期维表直接使用日期来做主键。如果需要不用的业务维度信息进行整合集成，这种情况比较适合生成代理键来做主键



## 物理模型设计：讲逻辑模型具体实施，考虑各种具体的技术实现因素，进行数据仓库体系结构设计，真正实现数据在数据仓库中的存放
物理建模主要分四步
- 主题域设计：从业务上，高度抽象和归纳，将数据划分为不同的主题域，分域后的好处：业务紧耦合、便于数据拓展、便于使用
    - 用户信息域
    - 数据业务
    - 账务
    - 客户服务
- 分层设计: 
    - 结合Inmon和Kimball的集线器式和总线式的数据仓库优点，分层为ODS-[MID]-DW-DM-OLAP/OLAM/APP
        - ODS层是将OLTP数据通过ETL同步到数据仓库来作为数据仓库最基础数据的来源，这这个过程中，数据经过了一定的清洗，脏数据的去除，但是数据的粒度不会变化。ODS层的数据可以只保存一定时间
        - MID中间层是采用Inmon集线器架构的方式，使用范式建模的方法。这一层主要是做规范化的事情，比如应用库表非规范化，字段格式复杂需做一些处理，这一层不是必须的，也不会对外开放使用。范式建模保证了数据的一致性、唯一性、正确性。
        - DW-DM层是采用Kimball的总线式的数据仓库架构，针对部门或者某一主题，通过维度建模，构建一致性维度原子粒度的数据是DW层，按照实体或者主题经过一定的汇总，建设数据集市模型，数据集市可以为OLAP提供服务
    - 接口层(存储层)
        - 日接口
        - 月接口
        - 增量接口
        - 全量接口
    - 中间汇总层
        - 深度汇总层
            - 信息聚合：用户统一视图
        - 轻度汇总层
    - 应用层(数据集市)
        - KPI报表
        - 主题分析
        - 指标库
- 维度建模：讲商业维度融合到数据模型中，它强调先对维度进行预处理，将多个维度集合到一个事实表，形成一个宽表
- 分区设计


## 数据库的三范式
- 第一范式：数据库表的字段都是单一属性，不可再分，比如电话可以分家庭电话和工作电话
- 第二范式：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖，即要求所有属性都要依赖于主键。如order(orderId，productId, productName, quantity), 主键为(orderId, productId), productName只依赖于productId 
- 第三方式：数据库表中不存在非关键字段对任一候选关键字段的传递函数依赖，如order(orderId, userId, userName)，userName依赖userId，userId依赖orderId