---
title: scala
date: 2018-08-23 10:03:16
tags:
---


### 隐式转换规则
- 什么时候会发生隐式转换
    * 当方法中参数的类型与实际类型不一致时
    * 当调用类中不存在的方法或成员时，会自动将对象进行隐式转换
- 什么时候不会发生隐式转换
    * 编译器可以不在隐式转换的编译通过，则不进行隐式转换
    * 如果转换存在二义性，则不会发生隐式转换
    * 隐式转换不会嵌套进行

### 函数中隐式参数使用概要
- 在定义函数时，如果函数没有柯里化，implicit关键字会作用于所有参数
- 要想使用implicit只作用于某个函数参数，则需要将函数进行柯里化
- 匿名函数不能使用隐式参数
- 如果函数带有隐式参数，则不能使用其偏函数

### 类型
- T<:M    => 类型变量界定 =>
- T:M     => 上下文界定   => M是一个泛型，要求存在一个M[T]类型的隐式值
- T:M:K   => 多重界定    => 在作用域中必须存在M[T]、K[T]类型的隐式值
- T<%M<%K => 多重界定    => 在作用域中必须存在T到M、T到K的隐式转换
- K>:T<:M => 多重界定    => M是T类型的超类，K也是T类型的超类
- T=:=U   => 类型约束    => 用于判断T是否等于U
- T<:<U   => 类型约束    => 用于判断T是否为U的子类
- _ <:    => 类型通配符   => 在使用时不具体指定它属于某个类，而是只知道其大致的类型范围
- <:<与<:区别
    * <:类型不匹配时，采用类型推断；<:<严格匹配，不会采用类型推断
    * 隐式转换可在<:类型变量界定中使用；隐式转换在<:<类型约束中不管用

### 协变和逆变
- 协变和逆变会破坏类型安全
- 协变: trait List[+T] {} => 当类型S是类型A的子类型时，则List[S]也可以认为是List[A}的子类型，即List[S]可以泛化为List[A]
- 逆变: trait List[-T] {} => 当类型S是类型A的子类型，则Queue[A]反过来可以认为是Queue[S}的子类型
